{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nvar PatternParser = /*#__PURE__*/function () {\n  function PatternParser() {\n    _classCallCheck(this, PatternParser);\n  }\n\n  _createClass(PatternParser, [{\n    key: \"parse\",\n    value: function parse(pattern) {\n      this.context = [{\n        or: true,\n        instructions: []\n      }];\n      this.parsePattern(pattern);\n\n      if (this.context.length !== 1) {\n        throw new Error('Non-finalized contexts left when pattern parse ended');\n      }\n\n      var _this$context$ = this.context[0],\n          branches = _this$context$.branches,\n          instructions = _this$context$.instructions;\n\n      if (branches) {\n        return {\n          op: '|',\n          args: branches.concat([expandSingleElementArray(instructions)])\n        };\n      }\n      /* istanbul ignore if */\n\n\n      if (instructions.length === 0) {\n        throw new Error('Pattern is required');\n      }\n\n      if (instructions.length === 1) {\n        return instructions[0];\n      }\n\n      return instructions;\n    }\n  }, {\n    key: \"startContext\",\n    value: function startContext(context) {\n      this.context.push(context);\n    }\n  }, {\n    key: \"endContext\",\n    value: function endContext() {\n      this.context.pop();\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.context[this.context.length - 1];\n    }\n  }, {\n    key: \"parsePattern\",\n    value: function parsePattern(pattern) {\n      if (!pattern) {\n        throw new Error('Pattern is required');\n      }\n\n      var match = pattern.match(OPERATOR);\n\n      if (!match) {\n        if (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {\n          throw new Error(\"Illegal characters found in a pattern: \".concat(pattern));\n        }\n\n        this.getContext().instructions = this.getContext().instructions.concat(pattern.split(''));\n        return;\n      }\n\n      var operator = match[1];\n      var before = pattern.slice(0, match.index);\n      var rightPart = pattern.slice(match.index + operator.length);\n\n      switch (operator) {\n        case '(?:':\n          if (before) {\n            this.parsePattern(before);\n          }\n\n          this.startContext({\n            or: true,\n            instructions: [],\n            branches: []\n          });\n          break;\n\n        case ')':\n          if (!this.getContext().or) {\n            throw new Error('\")\" operator must be preceded by \"(?:\" operator');\n          }\n\n          if (before) {\n            this.parsePattern(before);\n          }\n\n          if (this.getContext().instructions.length === 0) {\n            throw new Error('No instructions found after \"|\" operator in an \"or\" group');\n          }\n\n          var _this$getContext = this.getContext(),\n              branches = _this$getContext.branches;\n\n          branches.push(expandSingleElementArray(this.getContext().instructions));\n          this.endContext();\n          this.getContext().instructions.push({\n            op: '|',\n            args: branches\n          });\n          break;\n\n        case '|':\n          if (!this.getContext().or) {\n            throw new Error('\"|\" operator can only be used inside \"or\" groups');\n          }\n\n          if (before) {\n            this.parsePattern(before);\n          } // The top-level is an implicit \"or\" group, if required.\n\n\n          if (!this.getContext().branches) {\n            // `branches` are not defined only for the root implicit \"or\" operator.\n\n            /* istanbul ignore else */\n            if (this.context.length === 1) {\n              this.getContext().branches = [];\n            } else {\n              throw new Error('\"branches\" not found in an \"or\" group context');\n            }\n          }\n\n          this.getContext().branches.push(expandSingleElementArray(this.getContext().instructions));\n          this.getContext().instructions = [];\n          break;\n\n        case '[':\n          if (before) {\n            this.parsePattern(before);\n          }\n\n          this.startContext({\n            oneOfSet: true\n          });\n          break;\n\n        case ']':\n          if (!this.getContext().oneOfSet) {\n            throw new Error('\"]\" operator must be preceded by \"[\" operator');\n          }\n\n          this.endContext();\n          this.getContext().instructions.push({\n            op: '[]',\n            args: parseOneOfSet(before)\n          });\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"Unknown operator: \".concat(operator));\n      }\n\n      if (rightPart) {\n        this.parsePattern(rightPart);\n      }\n    }\n  }]);\n\n  return PatternParser;\n}();\n\nexport { PatternParser as default };\n\nfunction parseOneOfSet(pattern) {\n  var values = [];\n  var i = 0;\n\n  while (i < pattern.length) {\n    if (pattern[i] === '-') {\n      if (i === 0 || i === pattern.length - 1) {\n        throw new Error(\"Couldn't parse a one-of set pattern: \".concat(pattern));\n      }\n\n      var prevValue = pattern[i - 1].charCodeAt(0) + 1;\n      var nextValue = pattern[i + 1].charCodeAt(0) - 1;\n      var value = prevValue;\n\n      while (value <= nextValue) {\n        values.push(String.fromCharCode(value));\n        value++;\n      }\n    } else {\n      values.push(pattern[i]);\n    }\n\n    i++;\n  }\n\n  return values;\n}\n\nvar ILLEGAL_CHARACTER_REGEXP = /[\\(\\)\\[\\]\\?\\:\\|]/;\nvar OPERATOR = new RegExp( // any of:\n'(' + // or operator\n'\\\\|' + // or\n'|' + // or group start\n'\\\\(\\\\?\\\\:' + // or\n'|' + // or group end\n'\\\\)' + // or\n'|' + // one-of set start\n'\\\\[' + // or\n'|' + // one-of set end\n'\\\\]' + ')');\n\nfunction expandSingleElementArray(array) {\n  if (array.length === 1) {\n    return array[0];\n  }\n\n  return array;\n}","map":{"version":3,"sources":["../source/AsYouTypeFormatter.PatternParser.js"],"names":["PatternParser","or","instructions","branches","op","args","expandSingleElementArray","match","pattern","ILLEGAL_CHARACTER_REGEXP","operator","before","rightPart","oneOfSet","parseOneOfSet","values","i","prevValue","nextValue","value","String","OPERATOR","array"],"mappings":"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","sourcesContent":["export default class PatternParser {\r\n\tparse(pattern) {\r\n\t\tthis.context = [{\r\n\t\t\tor: true,\r\n\t\t\tinstructions: []\r\n\t\t}]\r\n\r\n\t\tthis.parsePattern(pattern)\r\n\r\n\t\tif (this.context.length !== 1) {\r\n\t\t\tthrow new Error('Non-finalized contexts left when pattern parse ended')\r\n\t\t}\r\n\r\n\t\tconst { branches, instructions } = this.context[0]\r\n\r\n\t\tif (branches) {\r\n\t\t\treturn {\r\n\t\t\t\top: '|',\r\n\t\t\t\targs: branches.concat([\r\n\t\t\t\t\texpandSingleElementArray(instructions)\r\n\t\t\t\t])\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* istanbul ignore if */\r\n\t\tif (instructions.length === 0) {\r\n\t\t\tthrow new Error('Pattern is required')\r\n\t\t}\r\n\r\n\t\tif (instructions.length === 1) {\r\n\t\t\treturn instructions[0]\r\n\t\t}\r\n\r\n\t\treturn instructions\r\n\t}\r\n\r\n\tstartContext(context) {\r\n\t\tthis.context.push(context)\r\n\t}\r\n\r\n\tendContext() {\r\n\t\tthis.context.pop()\r\n\t}\r\n\r\n\tgetContext() {\r\n\t\treturn this.context[this.context.length - 1]\r\n\t}\r\n\r\n\tparsePattern(pattern) {\r\n\t\tif (!pattern) {\r\n\t\t\tthrow new Error('Pattern is required')\r\n\t\t}\r\n\r\n\t\tconst match = pattern.match(OPERATOR)\r\n\t\tif (!match) {\r\n\t\t\tif (ILLEGAL_CHARACTER_REGEXP.test(pattern)) {\r\n\t\t\t\tthrow new Error(`Illegal characters found in a pattern: ${pattern}`)\r\n\t\t\t}\r\n\t\t\tthis.getContext().instructions = this.getContext().instructions.concat(\r\n\t\t\t\tpattern.split('')\r\n\t\t\t)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tconst operator = match[1]\r\n\t\tconst before = pattern.slice(0, match.index)\r\n\t\tconst rightPart = pattern.slice(match.index + operator.length)\r\n\r\n\t\tswitch (operator) {\r\n\t\t\tcase '(?:':\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tthis.startContext({\r\n\t\t\t\t\tor: true,\r\n\t\t\t\t\tinstructions: [],\r\n\t\t\t\t\tbranches: []\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase ')':\r\n\t\t\t\tif (!this.getContext().or) {\r\n\t\t\t\t\tthrow new Error('\")\" operator must be preceded by \"(?:\" operator')\r\n\t\t\t\t}\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.getContext().instructions.length === 0) {\r\n\t\t\t\t\tthrow new Error('No instructions found after \"|\" operator in an \"or\" group')\r\n\t\t\t\t}\r\n\t\t\t\tconst { branches } = this.getContext()\r\n\t\t\t\tbranches.push(\r\n\t\t\t\t\texpandSingleElementArray(\r\n\t\t\t\t\t\tthis.getContext().instructions\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t\tthis.endContext()\r\n\t\t\t\tthis.getContext().instructions.push({\r\n\t\t\t\t\top: '|',\r\n\t\t\t\t\targs: branches\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase '|':\r\n\t\t\t\tif (!this.getContext().or) {\r\n\t\t\t\t\tthrow new Error('\"|\" operator can only be used inside \"or\" groups')\r\n\t\t\t\t}\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\t// The top-level is an implicit \"or\" group, if required.\r\n\t\t\t\tif (!this.getContext().branches) {\r\n\t\t\t\t\t// `branches` are not defined only for the root implicit \"or\" operator.\r\n\t\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\t\tif (this.context.length === 1) {\r\n\t\t\t\t\t\tthis.getContext().branches = []\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error('\"branches\" not found in an \"or\" group context')\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.getContext().branches.push(\r\n\t\t\t\t\texpandSingleElementArray(\r\n\t\t\t\t\t\tthis.getContext().instructions\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t\tthis.getContext().instructions = []\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase '[':\r\n\t\t\t\tif (before) {\r\n\t\t\t\t\tthis.parsePattern(before)\r\n\t\t\t\t}\r\n\t\t\t\tthis.startContext({\r\n\t\t\t\t\toneOfSet: true\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\tcase ']':\r\n\t\t\t\tif (!this.getContext().oneOfSet) {\r\n\t\t\t\t\tthrow new Error('\"]\" operator must be preceded by \"[\" operator')\r\n\t\t\t\t}\r\n\t\t\t\tthis.endContext()\r\n\t\t\t\tthis.getContext().instructions.push({\r\n\t\t\t\t\top: '[]',\r\n\t\t\t\t\targs: parseOneOfSet(before)\r\n\t\t\t\t})\r\n\t\t\t\tbreak\r\n\r\n\t\t\t/* istanbul ignore next */\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(`Unknown operator: ${operator}`)\r\n\t\t}\r\n\r\n\t\tif (rightPart) {\r\n\t\t\tthis.parsePattern(rightPart)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction parseOneOfSet(pattern) {\r\n\tconst values = []\r\n\tlet i = 0\r\n\twhile (i < pattern.length) {\r\n\t\tif (pattern[i] === '-') {\r\n\t\t\tif (i === 0 || i === pattern.length - 1) {\r\n\t\t\t\tthrow new Error(`Couldn't parse a one-of set pattern: ${pattern}`)\r\n\t\t\t}\r\n\t\t\tconst prevValue = pattern[i - 1].charCodeAt(0) + 1\r\n\t\t\tconst nextValue = pattern[i + 1].charCodeAt(0) - 1\r\n\t\t\tlet value = prevValue\r\n\t\t\twhile (value <= nextValue) {\r\n\t\t\t\tvalues.push(String.fromCharCode(value))\r\n\t\t\t\tvalue++\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvalues.push(pattern[i])\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn values\r\n}\r\n\r\nconst ILLEGAL_CHARACTER_REGEXP = /[\\(\\)\\[\\]\\?\\:\\|]/\r\n\r\nconst OPERATOR = new RegExp(\r\n\t// any of:\r\n\t'(' +\r\n\t\t// or operator\r\n\t\t'\\\\|' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// or group start\r\n\t\t'\\\\(\\\\?\\\\:' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// or group end\r\n\t\t'\\\\)' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// one-of set start\r\n\t\t'\\\\[' +\r\n\t\t// or\r\n\t\t'|' +\r\n\t\t// one-of set end\r\n\t\t'\\\\]' +\r\n\t')'\r\n)\r\n\r\nfunction expandSingleElementArray(array) {\r\n\tif (array.length === 1) {\r\n\t\treturn array[0]\r\n\t}\r\n\treturn array\r\n}"]},"metadata":{},"sourceType":"module"}